use hashbrown::HashMap;
use lazy_static::lazy_static;
use regex::Regex;
use std::path::PathBuf;
use std::process::Command;

mod cli_args;
use cli_args::Args;
use clap::Parser;

fn git_repo_root(path: &str) -> Option<String> {
    let repo_root_out =
        Command::new("git")
                .arg("rev-parse")
                .arg("--show-toplevel")
                .current_dir(path)
                .output()
                .expect("git rev-parse failed to start");
    match repo_root_out.status.success() {
        false => return None,
        true => {
            let repo_root = String::from_utf8_lossy(&repo_root_out.stdout);
            return Some(repo_root.trim().to_string());
        },
    }
}

fn git_revision(repo_root: &str, branch: &Option<String>, date: &Option<String>) -> Option<String> {
    // git log --format=format:"%H" --before=2023-01-01
    let mut cmd = Command::new("git");
    cmd.arg("log");
    if let Some(branch) = branch {
        cmd.arg(branch);
    }
    cmd.arg("-n1").arg("--format=format:%H");
    if let Some(date) = date {
        cmd.arg(format!("--before={date}"));
    }
    let cmd_out = cmd
                .current_dir(repo_root)
                .output()
                .expect("git log failed to start");
    match cmd_out.status.success() {
        false => return None,
        true => {
            let revision = String::from_utf8_lossy(&cmd_out.stdout);
            return Some(revision.trim().to_string());
        },
    }
}

fn git_files(repo_root: &str, revision: &str) -> Vec<String> {
    let ls_tree_out =
        Command::new("git")
                .arg("ls-tree")
                .arg("-r")
                .arg(revision)
                .arg("--name-only")
                .current_dir(repo_root)
                .output()
                .expect("git ls-tree failed to start");
    return String::from_utf8_lossy(&ls_tree_out.stdout)
        .lines()
        .map(|x| x.to_string())
        .collect();
}

fn reason_to_skip(path_buf: &PathBuf) -> Option<String> {
    // List of file extensions to skip
    let binary_ext_list = [
        "bin",
        "data",
        "elf",
        "gz",
        "hex128",
        "hex8",
        "pdf",
        "png",
        "tar",
        "wcfg",
        "xlsx",
    ];

    let generated_ext_list = [
        "v",
        "xml",
        "edif",
        "edf",
        "rpt",
    ];

    if let Some(ext) = path_buf.extension() {
        let ext = ext.to_str().unwrap();
        if binary_ext_list.contains(&ext) {
            return Some("binary extension    ".to_string());
        }
        if generated_ext_list.contains(&ext) {
            return Some("autogenerated       ".to_string());
        }
    }

    if let Some(name) = path_buf.file_name() {
        let name = name.to_str().unwrap();
        if name.ends_with(".bd.tcl") {
            return Some("mostly autogenerated".to_string());
        }
    }

    let path = path_buf.to_str().unwrap();
    if path.contains("xip/") {
        return Some("mostly imported     ".to_string());
    }

    return None;
}

fn git_author_line_count_hash(repo_root: &str, revision: &str, file_path: &str) -> HashMap<String, i32> {
    let mut authors = HashMap::<String, i32>::new();

    let blame_out =
        Command::new("git")
                .arg("blame")
                .arg("--line-porcelain")
                .arg(revision)
                .arg(file_path)
                .current_dir(repo_root)
                .output()
                .expect("git blame failed to start");
    let auth_lines = String::from_utf8_lossy(&blame_out.stdout);
    auth_lines.lines().filter(|x| x.starts_with("author ")).for_each(|x| {
        let author = x[7..].to_string();
        *authors.entry_ref(&author).or_insert(0) += 1;
    });

    return authors;
}

fn _git_author_line_count_vec(repo_root: &str, revision: &str, file_path: &str) -> Vec<(String, i32)> {
    let mut authors = Vec::<(String, i32)>::new();

    let blame_out =
        Command::new("git")
                .arg("blame")
                .arg("--line-porcelain")
                .arg(revision)
                .arg(file_path)
                .current_dir(repo_root)
                .output()
                .expect("git blame failed to start");
    let auth_lines = String::from_utf8_lossy(&blame_out.stdout);
    auth_lines.lines().filter(|x| x.starts_with("author ")).for_each(|x| {
        let author = x[7..].to_string();
        match authors.iter().position(|x| x.0 == author) {
            Some(ii) => authors[ii].1 += 1,
            None => {
                authors.push((author.to_string(), 1));
            },
        }
    });

    return authors;
}

fn reformat(authors: &HashMap<String, i32>) -> HashMap<String, i32> {
    lazy_static! {
        // Regex for reformatting author names
        static ref RE_SPECIAL: Regex = Regex::new(r"[-_\.]").unwrap();
        static ref RE_CAPITAL: Regex = Regex::new(r"\b[a-z]").unwrap();
    };

    let mut formatted = HashMap::<String, i32>::new();

    authors.iter().for_each(|(author, count)| {
        // reformat author name
        let auth = RE_SPECIAL.replace_all(&author, " ").to_lowercase();
        let mut author = auth.clone();
        for mat in RE_CAPITAL.find_iter(&auth) {
            let mut c = author.chars().nth(mat.start()).unwrap();
            c = c.to_uppercase().nth(0).unwrap();
            author.replace_range(mat.start()..mat.start()+1, &c.to_string());
        }
        *formatted.entry_ref(&author).or_insert(0) += count;
    });

    return formatted;
}

fn display_results(opt: &Args, authors: &HashMap<String, i32>, skip_files: i32, use_files: i32) {
    let long_auth = authors.keys().map(|x| x.len()).max().unwrap_or(0);
    let line_tot = authors.values().fold(0, |acc, x| acc + x);

    //let mut mauthors = authors.to_owned();
    let mut auth_vec: Vec<(String, i32)> = authors.keys().map(|x| (x.to_string(), authors[x])).collect();
    if opt.alphabetical {
        auth_vec.sort_by(|a, b| a.0.cmp(&b.0));
    } else {
        auth_vec.sort_by(|a, b| b.1.cmp(&a.1));
    }
    let auth_vec = auth_vec;

    println!("Files used: {}, Files skipped: {}, lines counted: {}", use_files, skip_files, line_tot);
    for (author, count) in auth_vec {
        let count_str = match opt.as_percent {
            true => format!("{:>4.1}%", (100.0_f64 * count as f64) / (line_tot as f64)),
            false => format!("{}", count),
        };
        println!("{author:<long_auth$}: {count_str}");
    }
}

fn main() {
    let opt = Args::parse();

    let repo_root = git_repo_root(&opt.path).expect("Not a git repo");
    let revision = git_revision(&repo_root, &opt.branch, &opt.date).expect("Failed to get revision from branch and date");
    let files = git_files(&repo_root, &revision);

    let mut skip_files = 0_i32;
    let mut use_files = 0_i32;
    let files = files.iter().filter(|f| {
        let pb = PathBuf::from(&f);
        if let Some(reason) = reason_to_skip(&pb) {
            skip_files += 1;
            if opt.show_excluded {
                println!("Skipping b/c {reason}: {}", &f);
            }
            false
        } else {
            use_files += 1;
            true
        }
    });

    //let mut authors = Vec::<(String, i32)>::new(); // Vec of tuples instead of HashMap because it is faster for small sizes 
    let mut authors = HashMap::<String, i32>::new();

    for f in files {
        let lauth = git_author_line_count_hash(&repo_root, &revision, f);
        lauth.iter().for_each(|(author, count)| {
            *authors.entry_ref(author).or_insert(0) += count;
        });
    }
    let authors = authors;

    //------ Reformat author names

    let authors = reformat(&authors);

    display_results(&opt, &authors, skip_files, use_files);
}


